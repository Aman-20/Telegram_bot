// telegram-bot.js
import express from 'express';
import TelegramBot from "node-telegram-bot-api";
import dotenv from "dotenv";
import { GoogleGenerativeAI } from "@google/generative-ai";
import mongoose from 'mongoose';
import path from 'path';

dotenv.config();
const PORT = process.env.PORT || 3000;

mongoose.connect(process.env.MONGODB_CONNECT, { dbName: "Telegram"}).then((req, res) => {
  console.log("MongoDb is Connected....");
});

const userSchema = new mongoose.Schema({
  chatId: { type: String, required: true, unique: true },
  messages: [
    {
      role: { type: String, enum: ["user", "bot"], required: true },
      text: String,
      timestamp: { type: Date, default: Date.now }
    }
  ],
  requests: { type: Number, default: 0 },        // daily requests
  lastReset: { type: Date, default: Date.now },  // daily reset for requests
  usage: {
    tokensUsed: { type: Number, default: 0 },   // total tokens used today
    resetDate: { type: Date, default: Date.now } // when to reset quota
  }
});

const User = mongoose.model("User", userSchema);



const app = express();

// -- set view engine to ejs --
app.set("view engine", "ejs");

// -- ejs files
app.get("/", (req, res) => res.render("home"));
app.get("/privacy", (req, res) => res.render("privacy"));
app.get("/terms", (req, res) => res.render("terms"));


// --- Load API keys from .env ---
const TELEGRAM_TOKEN = process.env.TELEGRAM_TOKEN;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

// --- Initialize Telegram Bot ---
const bot = new TelegramBot(TELEGRAM_TOKEN);

// 2Ô∏è‚É£ Set the webhook URL
bot.setWebHook(`https://telegram-bot-1-qzck.onrender.com/bot${TELEGRAM_TOKEN}`);

// 3Ô∏è‚É£ Express route to receive updates
app.use(express.json());
app.post(`/bot${TELEGRAM_TOKEN}`, (req, res) => {
  bot.processUpdate(req.body);
  res.sendStatus(200);
});

// --- Running on this port ---
app.listen(PORT, () => console.log(`‚úÖ Web server running on port ${PORT}`));


// --- Register Commands with Telegram ---
bot.setMyCommands([
    { command: "start", description: "ü§ñAbout the bot" },
    { command: "help", description: "üìùList of commands" },
    { command: "account", description: "üë§ My account info" },
    { command: "language", description: "üåê Change language" },
    { command: "clearchat", description: "üßπ Clear chat history" },
    { command: "about", description: "üëÄAbout this bot" },
    { command: "terms", description: "üìú Terms of service" },
    
  ]);
  

// --- Initialize Gemini ---
const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

// Define supported languages
const LANGUAGES = {
    en: "üá¨üáß English",
    hi: "üáÆüá≥ Hindi",
    es: "üá™üá∏ Spanish",
    fr: "üá´üá∑ French",
    de: "üá©üá™ German",
    ja: "üáØüáµ Japanese",
    ru: "üá∑üá∫ Russian",
    ar: "üá∏üá¶ Arabic",
};
  

// --- Commands ---
bot.onText(/\/start/, (msg) => {
  bot.sendMessage(msg.chat.id, `üëã Hi ${msg.from.first_name}!
I am your AI assistant powered by Gemini.
Type any question and I‚Äôll try to answer.`);
});

bot.onText(/\/help/, (msg) => {
  bot.sendMessage(msg.chat.id, `üìå Available commands:
/start - Start the bot
/help - Show help
/about - About this bot
/clearchat - Clear chat history
/terms - Terms of services
/account - My account info
/language - Change language`);
});

bot.onText(/\/about/, (msg) => {
  bot.sendMessage(msg.chat.id, `ü§ñ This bot is built with:
- Telegram Bot API
- Google Gemini AI
- Node.js`);
});
  
bot.onText(/\/clearchat/, async (msg) => {
  const chatId = msg.chat.id;

  let user = await User.findOne({ chatId });
  if (!user) {
    bot.sendMessage(chatId, "‚ö†Ô∏è No chat history found.");
    return;
  }

  // ‚úÖ Clear all saved messages
  user.messages = [];
  await user.save();

  bot.sendMessage(chatId, "üßπ Your chat history has been cleared.");
});


bot.onText(/\/terms/, (msg) => {
    const chatId = msg.chat.id;
  
    const terms = `
  üìú *Terms of Service*
  
  1. This bot is provided for educational and personal use only.  
  2. Do not use this bot to share harmful, illegal, or inappropriate content.  
  3. The bot may store limited usage data to improve responses and enforce usage limits.  
  4. Responses are generated by AI (Gemini API) and may not always be accurate.  
  5. By using this bot, you agree to these terms.
  `;
  
    bot.sendMessage(chatId, terms, {
      parse_mode: "Markdown",
      reply_markup: {
        inline_keyboard: [
          [
            { text: "üìÑ Full Terms of Service", url: "https://telegram-bot-1-qzck.onrender.com/terms" },
            { text: "üîí Privacy Policy", url: "https://telegram-bot-1-qzck.onrender.com/privacy" }
          ]
        ]
      }
    });
  });
  
  
const DEFAULT_LIMIT = 20; // requests per day
const userData = {}; // { chatId: { requests: 0, limit: 20, lastReset: Date } }

function resetUserLimits() {
    const now = new Date();
  
    for (const chatId in userData) {
      const user = userData[chatId];
      const lastReset = user.lastReset || new Date(0);
      
      // If last reset was before today, reset requests
      if (lastReset.toDateString() !== now.toDateString()) {
        user.requests = 0;
        user.lastReset = now;
      }
    }
  }
  
// Run reset every hour (or any interval)
setInterval(resetUserLimits, 60 * 60 * 1000); // every 1 hour

  

// --- My Account ---
bot.onText(/\/account/, async (msg) => {
  const chatId = msg.chat.id;

  // Fetch user from DB
  let user = await User.findOne({ chatId });
  if (!user) {
    user = new User({
      chatId,
      requests: 0,
      lastReset: new Date(),
      usage: {tokensUsed: 0, resetDate: new Date()},
      messages: [],
    });
    await user.save();
  }

  const remainingRequests = 20 - user.requests;
  const usedTokens = user.usage?.tokensUsed || 0;
  const remainingTokens = 1000 - usedTokens;
  const lang = userLanguages[chatId] || "en";


  const resetTime = new Date();
  resetTime.setHours(24, 0, 0, 0); // midnight reset

  bot.sendMessage(
    chatId,
    `
üë§ *My Account*

- Requests used today: ${user.requests}
- Requests remaining: ${remainingRequests}
- Daily request limit: 20

- Tokens used today: ${usedTokens}
- Tokens remaining: ${remainingTokens}
- Daily token limit: 1000
- Max tokens per reply: 100

üåç Current language: ${LANGUAGES[lang]} (${lang})

üïí Quota resets at: ${resetTime.toLocaleString()}
    `,
    { parse_mode: "Markdown" }
  );
});


bot.onText(/\/language/, (msg) => {
    const chatId = msg.chat.id;
  
    // Convert LANGUAGES object to inline keyboard (2 buttons per row)
    const buttons = Object.entries(LANGUAGES).map(([code, name]) => {
      return { text: name, callback_data: `lang_${code}` };
    });
  
    // Split into rows of 2 buttons
    const keyboard = [];
    for (let i = 0; i < buttons.length; i += 2) {
      keyboard.push(buttons.slice(i, i + 2));
    }
  
    bot.sendMessage(chatId, "üåê Choose your language:", {
      reply_markup: { inline_keyboard: keyboard }
    });
});

const userLanguages = {}; // store user language in-memory

bot.on("callback_query", (query) => {
  const chatId = query.message.chat.id;

  if (query.data.startsWith("lang_")) {
    const lang = query.data.replace("lang_", "");
    userLanguages[chatId] = lang;

    bot.sendMessage(chatId, `‚úÖ Language changed to: ${LANGUAGES[lang]}`);
    bot.answerCallbackQuery(query.id);
  }
});
  

async function saveMessage(chatId, role, text) {
  let user = await User.findOne({ chatId });
  if (!user) {
    user = new User({ chatId });
  }

  user.messages.push({ role, text });

  // keep only last 10 messages
  if (user.messages.length > 10) {
    user.messages = user.messages.slice(-10);
  }

  await user.save();
}

async function checkAndUpdateUsage(chatId, tokensUsedNow) {
  let user = await User.findOne({ chatId });
  if (!user) {
    user = new User({ chatId });
  }

  const today = new Date();
  const resetDate = new Date(user.usage.resetDate);

  // reset daily
  if (today.toDateString() !== resetDate.toDateString()) {
    user.usage.tokensUsed = 0;
    user.usage.resetDate = today;
  }

  if (user.usage.tokensUsed + tokensUsedNow > 1000) {
    return { allowed: false, remaining: 0 };
  }

  user.usage.tokensUsed += tokensUsedNow;
  await user.save();

  return { allowed: true, remaining: 1000 - user.usage.tokensUsed };
}

// --- Chat with Gemini ---
bot.on("message", async (msg) => {
  const chatId = msg.chat.id;
  const text = msg.text;

  if (text && text.startsWith("/")) return; // ignore commands & empty

  if (!text) {
    bot.sendMessage(chatId, "üìÇ No files allowed ‚Äî please send text only.");
    return;
  }


  // Fetch or create user from DB
  let user = await User.findOne({ chatId });
  if (!user) {
    user = new User({
      chatId,
      requests: 0,
      lastReset: new Date(),
      usage: { tokensUsed: 0, resetDate: new Date() },
      messages: [],
    });
    await user.save();
  }

  // Reset request limits daily
  const today = new Date().toDateString();
  if (user.lastReset.toDateString() !== today) {
    user.requests = 0;
    user.lastReset = new Date();
  }

  // Reset token usage daily
  if (user.usage.resetDate.toDateString() !== today) {
    user.usage.tokensUsed = 0;
    user.usage.resetDate = new Date();
  }

  // Check request limit (20/day)
  if (user.requests >= 20) {
    bot.sendMessage(chatId, `‚ö†Ô∏è You‚Äôve reached your daily request limit (20). Try again tomorrow.`);
    return;
  }

  // Estimate input tokens
  const inputTokens = Math.ceil(text.split(/\s+/).length * 1.3);

  // Check token limit (1000/day)
  if (user.usage.tokensUsed + inputTokens >= 1000) {
    bot.sendMessage(chatId, `‚ö†Ô∏è You‚Äôve reached your daily token limit (1000). Try again tomorrow.`);
    return;
  }

  // Language
  const lang = userLanguages[chatId] || "en";

  try {
    bot.sendChatAction(chatId, "typing");

    // Get last 10 messages for context
    const history = user.messages
      .slice(-10)
      .map((m) => `${m.role}: ${m.text}`)
      .join("\n");

    // Ask Gemini with output limit
    const result = await model.generateContent({
      contents: [
        {
          role: "user",
          parts: [{ text: `Answer in ${LANGUAGES[lang]} (${lang})\n\nConversation so far:\n${history}\n\nUser: ${text}` }],
        },
      ],
      generationConfig: { maxOutputTokens: 100 }, // cap at 100 tokens
    });

    const reply = result?.response?.text() || "‚ö†Ô∏è No response from Gemini.";

    // Estimate output tokens
    const outputTokens = Math.ceil(reply.split(/\s+/).length * 1.3);

    // Final check for token limit
    if (user.usage.tokensUsed + inputTokens + outputTokens > 1000) {
      bot.sendMessage(chatId, "‚ö†Ô∏è This reply would exceed your daily token limit (1000). Try again tomorrow.");
      return;
    }

    // Save conversation in MongoDB
    user.messages.push({ role: "user", text });
    user.messages.push({ role: "bot", text: reply });

    //limit number of chat saved
    if (user.messages.length > 50) {
      user.messages = user.messages.slice(-50);
    }

    // Update usage
    user.requests += 1;
    user.usage.tokensUsed += inputTokens + outputTokens;
    await user.save();

    // Reply with usage info
    bot.sendMessage(
      chatId,
      reply + `\n\nü™ô Requests left: ${20 - user.requests}, Tokens left: ${1000 - user.usage.tokensUsed}`
    );
  } catch (err) {
    console.error("‚ùå BOT ERROR:", err);
    bot.sendMessage(chatId, "‚ö†Ô∏è Error: Could not process your request.");
  }
});


